/**
 * @gaetancovelli/heap
 * Generated by babel.
 * Author: Gaëtan Covelli
 * Last Updated: Wed, 18 Jan 2017 16:06:39 GMT
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Binary heap implementation in JavaScript ES6.
 * Author: Gaëtan Covelli
 * License: MIT
 *
 * peek() - O(1)
 * pop()  - O(log n)
 * push() - O(log n)
 *
 * Usage:
 *
 * new Heap()                         - Creates an empty min heap
 * new Heap(Heap.MAX_PROPERTY)        - Creates an empty max heap
 * new Heap(Heap.MIN_PROPERTY, array) - Creates a min heap from an exsiting array
 * new Heap(Heap.MAX_PROPERTY, array) - Creates a max heap from an exsiting array
 * heap.push(1)                       - Pushes a number to the heap
 * heap.push([1, 'Task number 1'])    - Pushes an array with priority value and a string to track
 * heap.push([1, {name: 'my task'}])  - Pushes an array with priority value and an object to track
 * heap.peek()                        - Returns the top element of the heap
 * heap.pop()                         - Pops and returns the top element of the heap
 *
 * This heap implementation uses a 0-based indexing.
 */
module.exports = function () {

  /**
   * Creates a new heap.
   *
   * @param {number} property - Optional. The property of the heap. 
   * Heap.MIN_PROPERTY (default) or Heap.MAX_PROPERTY.
   * @param {array} array - Optional. An existing array that will get heapified.
   */
  function Heap(property) {
    var array = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    _classCallCheck(this, Heap);

    this.elements = array;
    this.property = Heap.MIN_PROPERTY;

    if (property === Heap.MAX_PROPERTY) {
      this.property = Heap.MAX_PROPERTY;
    }

    if (this.elements.length > 0) {
      this._heapify();
    }
  }

  _createClass(Heap, [{
    key: "_getLeftChildIndex",
    value: function _getLeftChildIndex(parentIndex) {
      return parentIndex * 2 + 1;
    }
  }, {
    key: "_getRightChildIndex",
    value: function _getRightChildIndex(parentIndex) {
      return parentIndex * 2 + 2;
    }
  }, {
    key: "_getParentIndex",
    value: function _getParentIndex(childIndex) {
      return parseInt((childIndex - 1) / 2);
    }
  }, {
    key: "_swap",
    value: function _swap(i, j) {
      var _ref = [this.elements[j], this.elements[i]];
      this.elements[i] = _ref[0];
      this.elements[j] = _ref[1];
    }

    /**
     * Returns the top element of the heap.
     *
     * @return {element} - The element at the top of the heap.
     */

  }, {
    key: "peek",
    value: function peek() {
      return this.elements[0];
    }

    /**
     * Pops and returns the top element of the heap.
     *
     * @return {element} - The element popped from the top of the heap.
     * It can be a number or an array whose first element is the priority value
     * and second element is the record tracked.
     */

  }, {
    key: "pop",
    value: function pop() {
      var lastValue = this.elements.pop();
      var returnVal = lastValue;
      if (this.elements.length > 0) {
        returnVal = this.elements[0];
        this.elements[0] = lastValue;
        this._heapifyDown();
      }
      return returnVal;
    }

    /**
     * Pushes a new element to the heap.
     *
     * @param {element} value - The element to be pushed to the heap.
     * It can be a number or an array whose first element is the priority value
     * and second element is the record we want to track.
     *
     * push(1); // A value
     * push([1, 'My task with priority value 1']); // A string
     * push([1, {firstname: 'Gaetan', lastname: 'Covelli'}]); // An object
     */

  }, {
    key: "push",
    value: function push(value) {
      this.elements.push(value);
      if (this.elements.length > 1) {
        this._heapifyUp(this.elements.length - 1);
      }
    }
  }, {
    key: "_heapifyUp",
    value: function _heapifyUp(index) {
      while (this._getParentIndex(index) >= 0) {
        var swapNeeded = false;
        var parentIndex = this._getParentIndex(index);

        if (this.property === Heap.MIN_PROPERTY) {
          swapNeeded = this.elements[parentIndex] > this.elements[index];
        } else if (this.property === Heap.MAX_PROPERTY) {
          swapNeeded = this.elements[parentIndex] < this.elements[index];
        }

        if (swapNeeded) {
          this._swap(parentIndex, index);
          index = parentIndex;
        } else {
          break;
        }
      }
    }
  }, {
    key: "_heapifyDown",
    value: function _heapifyDown() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      while (this._getLeftChildIndex(index) < this.elements.length) {
        var indexToSwap = this._getLeftChildIndex(index);
        var rightChildIndex = this._getRightChildIndex(index);
        var isRightChildSwap = false;

        if (this.property === Heap.MIN_PROPERTY) {
          isRightChildSwap = this.elements[rightChildIndex] < this.elements[indexToSwap];
        } else if (this.property === Heap.MAX_PROPERTY) {
          isRightChildSwap = this.elements[rightChildIndex] > this.elements[indexToSwap];
        }

        if (rightChildIndex < this.elements.length && isRightChildSwap) {
          indexToSwap = rightChildIndex;
        }

        var swapFinished = false;
        if (this.property === Heap.MIN_PROPERTY) {
          swapFinished = this.elements[index] < this.elements[indexToSwap];
        } else if (this.property === Heap.MAX_PROPERTY) {
          swapFinished = this.elements[index] > this.elements[indexToSwap];
        }

        if (swapFinished) {
          break;
        } else {
          this._swap(index, indexToSwap);
        }
        index = indexToSwap;
      }
    }

    /**
     * Heapifies an existing array.
     */

  }, {
    key: "_heapify",
    value: function _heapify() {
      for (var i = parseInt(this.elements.length / 2); i >= 0; i--) {
        this._heapifyDown(i);
      }
    }
  }], [{
    key: "MIN_PROPERTY",
    get: function get() {
      return 0;
    }
  }, {
    key: "MAX_PROPERTY",
    get: function get() {
      return 1;
    }
  }]);

  return Heap;
}();